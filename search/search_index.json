{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Start Here This is the Cleura Beta documentation web site. We are currently in the process of migrating our Knowledge Base and other documentation to this site. If you want to help, here\u2019s how!","title":"Start Here"},{"location":"#start-here","text":"This is the Cleura Beta documentation web site. We are currently in the process of migrating our Knowledge Base and other documentation to this site. If you want to help, here\u2019s how!","title":"Start Here"},{"location":"concepts/","text":"Concepts and Background This section contains conceptual and background information about Cleura and the services we support. This is not so much about how you do something (for that, please see our How-To Guides ), more about why things work in a certain way, or why we have implemented them in a particular way in Cleura.","title":"Concepts and Background"},{"location":"concepts/#concepts-and-background","text":"This section contains conceptual and background information about Cleura and the services we support. This is not so much about how you do something (for that, please see our How-To Guides ), more about why things work in a certain way, or why we have implemented them in a particular way in Cleura.","title":"Concepts and Background"},{"location":"contrib/","text":"Contribution Guide See something on this site that is inaccurate, missing, or that could simply be improved? There are multiple ways for you to help make this site better, and we welcome all of them. Technical Writing Resources Whether you are an experienced technical writer, a regular (or not-so-regular) open source contributor, or you\u2019re making your very first writing contribution, there are a ton of helpful resources on technical writing. Here are a few: Digital Ocean \u2019s Technical Writing Guidelines Red Hat \u2019s Writing Style Guide Gareth Dwyer \u2019s Technical Writing repository Bolaji Ayodeji \u2019s Awesome Technical Writing collection Markdown The documentation on this site uses Markdown . Markdown is a documentation format that is rich enough to be useful for good technical documentation, and yet simpler and easier to learn than other formats like reStructuredText or DocBook XML. If you\u2019re unfamiliar with Markdown, you can read up on its basics in this classic article by John Gruber if you\u2019re interested, but chances are that you\u2019ll also find all the information you\u2019ll need in this cheat sheet by Adam Pritchard , or the Start Writing guide from GitHub . Or you simply look at the source of one of the pages on this site (try the Edit button on this one!) and figure it out as you go along \u2014 it\u2019s really pretty straightforward. Modifications to content on this site You have two options for editing content: directly in your browser using GitHub, or using a Git-based workflow from your local work environment. Making contributions from your browser Every page on this site has an Edit button \ud83d\udd8d\ufe0f. If you click it, it\u2019ll take you straight to the corresponding source page in GitHub. Then, you can follow GitHub\u2019s documentation on how to propose changes to another user\u2019s repository. Making contributions using Git The Git repository for this site lives at https://github.com/citynetwork/docs . You can fork that repository, make the proposed changes in your fork, and then send us a standard GitHub pull request . If you would like to see your changes as you are working on them, you can do that with tox . Having checked out the topic branch with your modifications, run: tox -e serve A local copy of the documentation will then run on your local machine and be accessible from http://localhost:8000 in your browser. Quality checks There are a few checks that we apply to the configuration. They run automatically via GitHub Actions workflows when you send your PR: We check the commit message with gitlint , and enforce the Conventional Commits commit message style. We check whether the documentation still builds correctly, with your change applied. We check to make sure that no internal or external links in the documentation are dead. This is one example where the checks might fail through no fault of yours at all \u2014 some external link may have disappeared between the most recent change and your contribution, by pure coincidence. When that happens, we\u2019ll fix it together. We check some YAML conventions with yamllint . However, most contributions would probably only touch Markdown files and not YAML, so you\u2019re unlikely to trip over this. If you\u2019re working in your local Git repository and your work environment has tox installed, you can also run the checks locally: tox You can also configure your local checkout to run quality checks on each commit. To do that, run: git config core.hooksPath .githooks License With the sole exception of trademarks like \u201cCleura\u201d and the Cleura logo, the content on this site is available under the Creative Commons Attribution-ShareAlike 4.0 International license , as you can see from the icon at the bottom of each page. Please keep in mind that you are making your contribution under those terms.","title":"Contribution Guide"},{"location":"contrib/#contribution-guide","text":"See something on this site that is inaccurate, missing, or that could simply be improved? There are multiple ways for you to help make this site better, and we welcome all of them.","title":"Contribution Guide"},{"location":"contrib/#technical-writing-resources","text":"Whether you are an experienced technical writer, a regular (or not-so-regular) open source contributor, or you\u2019re making your very first writing contribution, there are a ton of helpful resources on technical writing. Here are a few: Digital Ocean \u2019s Technical Writing Guidelines Red Hat \u2019s Writing Style Guide Gareth Dwyer \u2019s Technical Writing repository Bolaji Ayodeji \u2019s Awesome Technical Writing collection","title":"Technical Writing Resources"},{"location":"contrib/#markdown","text":"The documentation on this site uses Markdown . Markdown is a documentation format that is rich enough to be useful for good technical documentation, and yet simpler and easier to learn than other formats like reStructuredText or DocBook XML. If you\u2019re unfamiliar with Markdown, you can read up on its basics in this classic article by John Gruber if you\u2019re interested, but chances are that you\u2019ll also find all the information you\u2019ll need in this cheat sheet by Adam Pritchard , or the Start Writing guide from GitHub . Or you simply look at the source of one of the pages on this site (try the Edit button on this one!) and figure it out as you go along \u2014 it\u2019s really pretty straightforward.","title":"Markdown"},{"location":"contrib/#modifications-to-content-on-this-site","text":"You have two options for editing content: directly in your browser using GitHub, or using a Git-based workflow from your local work environment.","title":"Modifications to content on this site"},{"location":"contrib/#making-contributions-from-your-browser","text":"Every page on this site has an Edit button \ud83d\udd8d\ufe0f. If you click it, it\u2019ll take you straight to the corresponding source page in GitHub. Then, you can follow GitHub\u2019s documentation on how to propose changes to another user\u2019s repository.","title":"Making contributions from your browser"},{"location":"contrib/#making-contributions-using-git","text":"The Git repository for this site lives at https://github.com/citynetwork/docs . You can fork that repository, make the proposed changes in your fork, and then send us a standard GitHub pull request . If you would like to see your changes as you are working on them, you can do that with tox . Having checked out the topic branch with your modifications, run: tox -e serve A local copy of the documentation will then run on your local machine and be accessible from http://localhost:8000 in your browser.","title":"Making contributions using Git"},{"location":"contrib/#quality-checks","text":"There are a few checks that we apply to the configuration. They run automatically via GitHub Actions workflows when you send your PR: We check the commit message with gitlint , and enforce the Conventional Commits commit message style. We check whether the documentation still builds correctly, with your change applied. We check to make sure that no internal or external links in the documentation are dead. This is one example where the checks might fail through no fault of yours at all \u2014 some external link may have disappeared between the most recent change and your contribution, by pure coincidence. When that happens, we\u2019ll fix it together. We check some YAML conventions with yamllint . However, most contributions would probably only touch Markdown files and not YAML, so you\u2019re unlikely to trip over this. If you\u2019re working in your local Git repository and your work environment has tox installed, you can also run the checks locally: tox You can also configure your local checkout to run quality checks on each commit. To do that, run: git config core.hooksPath .githooks","title":"Quality checks"},{"location":"contrib/#license","text":"With the sole exception of trademarks like \u201cCleura\u201d and the Cleura logo, the content on this site is available under the Creative Commons Attribution-ShareAlike 4.0 International license , as you can see from the icon at the bottom of each page. Please keep in mind that you are making your contribution under those terms.","title":"License"},{"location":"howto/","text":"About our How-To guides In this section you\u2019ll find details about how you can accomplish specific tasks in Cleura and the services we support. There are several categories of How-To guides, and they tend to be focused on a specific cloud technology. OpenStack CLI/API How-Tos cover tasks that you can accomplish with the OpenStack command line interfaces and application programming interfaces. They generally do not depend on any adjacent services or tools, just your Cleura OpenStack credentials, the openstack client, and/or the native OpenStack APIs. Object storage How-Tos deal with the S3 and Swift object storage APIs, and how you can use them for object storage in Cleura.","title":"About our How-To guides"},{"location":"howto/#about-our-how-to-guides","text":"In this section you\u2019ll find details about how you can accomplish specific tasks in Cleura and the services we support. There are several categories of How-To guides, and they tend to be focused on a specific cloud technology. OpenStack CLI/API How-Tos cover tasks that you can accomplish with the OpenStack command line interfaces and application programming interfaces. They generally do not depend on any adjacent services or tools, just your Cleura OpenStack credentials, the openstack client, and/or the native OpenStack APIs. Object storage How-Tos deal with the S3 and Swift object storage APIs, and how you can use them for object storage in Cleura.","title":"About our How-To guides"},{"location":"howto/object-storage/s3-credentials/","text":"Working with S3-compatible credentials When you want to interact with object storage in Cleura using tools that support an Amazon S3 compatible API (such as s3cmd , rclone , the aws CLI, or the Python boto3 library), you need an S3-compatible access key ID and secret key. Creating credentials You can create a set of S3-compatible credentials with the following command: openstack ec2 credentials create This will return an Access and Secret key that you can use to populate the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables (or whichever configuration options your application requires). Your S3-compatible credentials are always scoped to your Cleura region and project . You cannot reuse an access and secret key across multiple regions or projects. Also, your credentials are only \u201cS3-compatible\u201d in the sense that they use the same format as AWS S3 does. They are never valid against AWS S3 itself. Listing credentials You can list any previously-created credentials with: openstack ec2 credentials list Deleting credentials If at any time you need to delete a set of AWS-compatible credentials, you can do so with the following command: openstack ec2 credentials delete <access-key-id> Deleting a set of S3-compatible credentials will immediately revoke access for any applications that were using it.","title":"Working with S3-compatible credentials"},{"location":"howto/object-storage/s3-credentials/#working-with-s3-compatible-credentials","text":"When you want to interact with object storage in Cleura using tools that support an Amazon S3 compatible API (such as s3cmd , rclone , the aws CLI, or the Python boto3 library), you need an S3-compatible access key ID and secret key.","title":"Working with S3-compatible credentials"},{"location":"howto/object-storage/s3-credentials/#creating-credentials","text":"You can create a set of S3-compatible credentials with the following command: openstack ec2 credentials create This will return an Access and Secret key that you can use to populate the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables (or whichever configuration options your application requires). Your S3-compatible credentials are always scoped to your Cleura region and project . You cannot reuse an access and secret key across multiple regions or projects. Also, your credentials are only \u201cS3-compatible\u201d in the sense that they use the same format as AWS S3 does. They are never valid against AWS S3 itself.","title":"Creating credentials"},{"location":"howto/object-storage/s3-credentials/#listing-credentials","text":"You can list any previously-created credentials with: openstack ec2 credentials list","title":"Listing credentials"},{"location":"howto/object-storage/s3-credentials/#deleting-credentials","text":"If at any time you need to delete a set of AWS-compatible credentials, you can do so with the following command: openstack ec2 credentials delete <access-key-id> Deleting a set of S3-compatible credentials will immediately revoke access for any applications that were using it.","title":"Deleting credentials"},{"location":"howto/object-storage/sse-c/","text":"Client-side encryption with S3 API (SSE-C) You can use objects encryption via S3 API, according to the Amazon SSE-C specification. This means that you need to provide an encryption/decryption key with each request to the object. You can store the encryption key in Barbican, and provide it to the S3 client at runtime. Below we will provide more detailed explanation regarding how to use this in your workloads. Requirements This guide assumes familiarity with the following tools: python-openstackclient (with the python-barbicanclient plugin), pwgen , rclone version 1.54 or later. Create encryption details According to SSE-C specification, in order to use server-side encryption, any S3 client needs to provide three pieces of information, which it includes in the request headers for each S3 request being made: Encryption algorithm: the only valid option here is AES256. Encryption key: a generated random key that we will store in Barbican. It should be valid AES key, which means that key length must be 32 bytes. Encryption key checksum: MD5 checksum of the encryption key. It's used for integrity checks. In order to generate encryption key and store it in Barbican, proceed as follows. Generate secret: secret_raw=$(pwgen 32 1) Store secret in Barbican: barbican_secret_url=$(openstack secret store --name objectSecret --algorithm aes --bit-length 256 --payload ${secret_raw} -f value -c 'Secret href') Retrieve secret from Barbican: secret=$(openstack secret get ${barbican_secret_url} -p -c Payload -f value) Managing encrypted objects in S3 (with rclone ) SSE-C encryption has been implemented/fixed with version 1.54. Prior rclone versions won't work here. Download and install the latest rclone for your distribution: https://rclone.org/downloads/ Create or retrieve your access key ID and secret key . Create a configuration file named ~/.rclone.conf , with the following content: [cleura] type = s3 provider = Ceph env_auth = false access_key_id = <access key id> secret_access_key = <secret key> endpoint = <region>.citycloud.com:8080 acl = private sse_customer_algorithm = AES256 Create an S3 bucket: rclone mkdir cleura:encrypted Sync a directory to the S3 bucket, encrypting the files it contains on upload: rclone sync ~/media/ cleura:encrypted \\ --s3-sse-customer-key=${secret} Retrieve a file from S3 and decrypt it: rclone copy cleura:encrypted/file.png \\ --s3-sse-customer-key=${secret} For more examples on how to use rclone, please use its reference documentation: https://rclone.org/docs/#subcommands","title":"Client-side encryption with S3 API (SSE-C)"},{"location":"howto/object-storage/sse-c/#client-side-encryption-with-s3-api-sse-c","text":"You can use objects encryption via S3 API, according to the Amazon SSE-C specification. This means that you need to provide an encryption/decryption key with each request to the object. You can store the encryption key in Barbican, and provide it to the S3 client at runtime. Below we will provide more detailed explanation regarding how to use this in your workloads.","title":"Client-side encryption with S3 API (SSE-C)"},{"location":"howto/object-storage/sse-c/#requirements","text":"This guide assumes familiarity with the following tools: python-openstackclient (with the python-barbicanclient plugin), pwgen , rclone version 1.54 or later.","title":"Requirements"},{"location":"howto/object-storage/sse-c/#create-encryption-details","text":"According to SSE-C specification, in order to use server-side encryption, any S3 client needs to provide three pieces of information, which it includes in the request headers for each S3 request being made: Encryption algorithm: the only valid option here is AES256. Encryption key: a generated random key that we will store in Barbican. It should be valid AES key, which means that key length must be 32 bytes. Encryption key checksum: MD5 checksum of the encryption key. It's used for integrity checks. In order to generate encryption key and store it in Barbican, proceed as follows. Generate secret: secret_raw=$(pwgen 32 1) Store secret in Barbican: barbican_secret_url=$(openstack secret store --name objectSecret --algorithm aes --bit-length 256 --payload ${secret_raw} -f value -c 'Secret href') Retrieve secret from Barbican: secret=$(openstack secret get ${barbican_secret_url} -p -c Payload -f value)","title":"Create encryption details"},{"location":"howto/object-storage/sse-c/#managing-encrypted-objects-in-s3-with-rclone","text":"SSE-C encryption has been implemented/fixed with version 1.54. Prior rclone versions won't work here. Download and install the latest rclone for your distribution: https://rclone.org/downloads/ Create or retrieve your access key ID and secret key . Create a configuration file named ~/.rclone.conf , with the following content: [cleura] type = s3 provider = Ceph env_auth = false access_key_id = <access key id> secret_access_key = <secret key> endpoint = <region>.citycloud.com:8080 acl = private sse_customer_algorithm = AES256 Create an S3 bucket: rclone mkdir cleura:encrypted Sync a directory to the S3 bucket, encrypting the files it contains on upload: rclone sync ~/media/ cleura:encrypted \\ --s3-sse-customer-key=${secret} Retrieve a file from S3 and decrypt it: rclone copy cleura:encrypted/file.png \\ --s3-sse-customer-key=${secret} For more examples on how to use rclone, please use its reference documentation: https://rclone.org/docs/#subcommands","title":"Managing encrypted objects in S3 (with rclone)"},{"location":"howto/openstack/barbican/","text":"Using Barbican for secret storage Barbican is OpenStack's secret storage facility. In Cleura, Barbican is supported for the following purposes: Generic secret storage , encryption for persistent volumes , certificate storage for HTTPS load balancers . To manage secrets with Barbican, you will need the openstack command line interface (CLI), and its Barbican plugin. You can install them both with the following commands: pip install python-openstackclient python-barbicanclient On Debian/Ubuntu platforms, you may also install these utilities via their APT packages: apt install python3-openstackclient python3-barbicanclient","title":"Using Barbican for secret storage"},{"location":"howto/openstack/barbican/#using-barbican-for-secret-storage","text":"Barbican is OpenStack's secret storage facility. In Cleura, Barbican is supported for the following purposes: Generic secret storage , encryption for persistent volumes , certificate storage for HTTPS load balancers . To manage secrets with Barbican, you will need the openstack command line interface (CLI), and its Barbican plugin. You can install them both with the following commands: pip install python-openstackclient python-barbicanclient On Debian/Ubuntu platforms, you may also install these utilities via their APT packages: apt install python3-openstackclient python3-barbicanclient","title":"Using Barbican for secret storage"},{"location":"howto/openstack/barbican/generic-secret/","text":"Generic secret storage The simplest way to use Barbican is to create and retrieve a securely stored, generic secret. How to store a generic secret It is possible to store any secret data with Barbican. The command below will create a secret of the type passphrase , named mysecret , which contains the passphrase my very secret passphrase . openstack secret store \\ --secret-type passphrase \\ -p \"my very secret passphrase\" \\ -n mysecret The example output below uses Cleura\u2019s Fra1 region. In other regions, the secret URIs will differ. +---------------+--------------------------------------------------------------------------------+ | Field | Value | +---------------+--------------------------------------------------------------------------------+ | Secret href | https://fra1.citycloud.com:9311/v1/secrets/33ef0985-f89e-4bf0-b318-887ecac0cba | | Name | mysecret | | Created | None | | Status | None | | Content types | None | | Algorithm | aes | | Bit length | 256 | | Secret type | passphrase | | Mode | cbc | | Expiration | None | +---------------+--------------------------------------------------------------------------------+ Note that passphrase type secrets are symmetrically encrypted, using the AES encryption algorithm with a 256-bit key length. You can select other bit lengths and algorithms with the -b and -a command line options, if desired. How to retrieve secrets Secrets are stored in Barbican in an encrypted format. You can see a list of secrets created for your user with the following command: openstack secret list +--------------------------------------------------------------------------------+----------+---------------------------+--------+-----------------------------------------+-----------+------------+-------------+------+------------+ | Secret href | Name | Created | Status | Content types | Algorithm | Bit length | Secret type | Mode | Expiration | +--------------------------------------------------------------------------------+----------+---------------------------+--------+-----------------------------------------+-----------+------------+-------------+------+------------+ | https://fra1.citycloud.com:9311/v1/secrets/33ef0985-f89e-4bf0-b318-887ecac0cba | mysecret | 2021-04-29T10:33:18+00:00 | ACTIVE | {'default': 'application/octet-stream'} | aes | 256 | passphrase | cbc | None | | https://fra1.citycloud.com:9311/v1/secrets/ad628532-53b8-4d2f-91e5-0097b51da4e | None | 2021-04-27T13:52:10+00:00 | ACTIVE | {'default': 'application/octet-stream'} | aes | 256 | symmetric | None | None | +--------------------------------------------------------------------------------+----------+---------------------------+--------+-----------------------------------------+-----------+------------+-------------+------+------------+ You can retrieve the decrypted secret with the openstack secret get command, adding the -p (or --payload ) option: $ openstack secret get -p \\ https://fra1.citycloud.com:9311/v1/secrets/33ef0985-f89e-4bf0-b318-887ecac0cba +---------+---------------------------+ | Field | Value | +---------+---------------------------+ | Payload | my very secret passphrase | +---------+---------------------------+ Unlike many other OpenStack services, which allow you to retrieve object references by name or UUID, Barbican only lets you retrieve secrets by their full URI . That URI must include the https://<region>.citycloud.com:9311/v1/secrets/ prefix.","title":"Generic secret storage"},{"location":"howto/openstack/barbican/generic-secret/#generic-secret-storage","text":"The simplest way to use Barbican is to create and retrieve a securely stored, generic secret.","title":"Generic secret storage"},{"location":"howto/openstack/barbican/generic-secret/#how-to-store-a-generic-secret","text":"It is possible to store any secret data with Barbican. The command below will create a secret of the type passphrase , named mysecret , which contains the passphrase my very secret passphrase . openstack secret store \\ --secret-type passphrase \\ -p \"my very secret passphrase\" \\ -n mysecret The example output below uses Cleura\u2019s Fra1 region. In other regions, the secret URIs will differ. +---------------+--------------------------------------------------------------------------------+ | Field | Value | +---------------+--------------------------------------------------------------------------------+ | Secret href | https://fra1.citycloud.com:9311/v1/secrets/33ef0985-f89e-4bf0-b318-887ecac0cba | | Name | mysecret | | Created | None | | Status | None | | Content types | None | | Algorithm | aes | | Bit length | 256 | | Secret type | passphrase | | Mode | cbc | | Expiration | None | +---------------+--------------------------------------------------------------------------------+ Note that passphrase type secrets are symmetrically encrypted, using the AES encryption algorithm with a 256-bit key length. You can select other bit lengths and algorithms with the -b and -a command line options, if desired.","title":"How to store a generic secret"},{"location":"howto/openstack/barbican/generic-secret/#how-to-retrieve-secrets","text":"Secrets are stored in Barbican in an encrypted format. You can see a list of secrets created for your user with the following command: openstack secret list +--------------------------------------------------------------------------------+----------+---------------------------+--------+-----------------------------------------+-----------+------------+-------------+------+------------+ | Secret href | Name | Created | Status | Content types | Algorithm | Bit length | Secret type | Mode | Expiration | +--------------------------------------------------------------------------------+----------+---------------------------+--------+-----------------------------------------+-----------+------------+-------------+------+------------+ | https://fra1.citycloud.com:9311/v1/secrets/33ef0985-f89e-4bf0-b318-887ecac0cba | mysecret | 2021-04-29T10:33:18+00:00 | ACTIVE | {'default': 'application/octet-stream'} | aes | 256 | passphrase | cbc | None | | https://fra1.citycloud.com:9311/v1/secrets/ad628532-53b8-4d2f-91e5-0097b51da4e | None | 2021-04-27T13:52:10+00:00 | ACTIVE | {'default': 'application/octet-stream'} | aes | 256 | symmetric | None | None | +--------------------------------------------------------------------------------+----------+---------------------------+--------+-----------------------------------------+-----------+------------+-------------+------+------------+ You can retrieve the decrypted secret with the openstack secret get command, adding the -p (or --payload ) option: $ openstack secret get -p \\ https://fra1.citycloud.com:9311/v1/secrets/33ef0985-f89e-4bf0-b318-887ecac0cba +---------+---------------------------+ | Field | Value | +---------+---------------------------+ | Payload | my very secret passphrase | +---------+---------------------------+ Unlike many other OpenStack services, which allow you to retrieve object references by name or UUID, Barbican only lets you retrieve secrets by their full URI . That URI must include the https://<region>.citycloud.com:9311/v1/secrets/ prefix.","title":"How to retrieve secrets"},{"location":"howto/openstack/barbican/share-secret/","text":"Sharing secrets via ACLs Normally, a Barbican secret is only available to the OpenStack API user that created it. However, under some circumstances it may be desirable to make a secret available to another user. To do so, you will need the secret\u2019s URI , the other user\u2019s OpenStack API user ID. Any Cleura user can always retrieve their own user ID with the following command: openstack token issue -f value -c user_id Once you have assembled this information, you can proceed with the openstack acl user add command: openstack acl user add \\ --user <user_id> \\ --operation-type read \\ https://region.citycloud.com:9311/v1/secrets/<secret_id> If you want to unshare the secret again, you simply use the corresponding openstack acl user remove command: openstack acl user remove \\ --user <user_id> \\ --operation-type read \\ https://region.citycloud.com:9311/v1/secrets/<secret_id>","title":"Sharing secrets via ACLs"},{"location":"howto/openstack/barbican/share-secret/#sharing-secrets-via-acls","text":"Normally, a Barbican secret is only available to the OpenStack API user that created it. However, under some circumstances it may be desirable to make a secret available to another user. To do so, you will need the secret\u2019s URI , the other user\u2019s OpenStack API user ID. Any Cleura user can always retrieve their own user ID with the following command: openstack token issue -f value -c user_id Once you have assembled this information, you can proceed with the openstack acl user add command: openstack acl user add \\ --user <user_id> \\ --operation-type read \\ https://region.citycloud.com:9311/v1/secrets/<secret_id> If you want to unshare the secret again, you simply use the corresponding openstack acl user remove command: openstack acl user remove \\ --user <user_id> \\ --operation-type read \\ https://region.citycloud.com:9311/v1/secrets/<secret_id>","title":"Sharing secrets via ACLs"},{"location":"howto/openstack/cinder/encrypted-volumes/","text":"Encrypted volumes When using Barbican for block storage encryption, you ensure that data in persistent storage volumes is stored in an encrypted fashion. That encryption is transparent to virtual machines (instances) that you attach the volume to. Creating an encrypted volume For the creation of an encrypted volume, you need to provide a specific volume type. You can retrieve the list of available volume types with the following command: openstack volume type list +--------------------------------------+-----------------------+-----------+ | ID | Name | Is Public | +--------------------------------------+-----------------------+-----------+ | a479a6b0-b283-41a5-b38b-5b08e7f902ca | volumes_hdd_encrypted | True | | d9dfa98a-238d-4ca0-9abf-701fceb05623 | __DEFAULT__ | True | | 86796611-fb12-4628-b6b1-e09469e301d7 | volumes_hdd | True | +--------------------------------------+-----------------------+-----------+ In Cleura, all volume types that support encryption use the suffix _encrypted . To create a volume with encryption, you need to explicitly specify the --type option to the openstack volume create command. The following example creates a volume using the volumes_hdd_encrypted type, naming it enc_drive and setting its size to 10 GiB: openstack volume create \\ --type volumes_hdd_encrypted \\ --size 10 \\ enc_drive +---------------------+--------------------------------------+ | Field | Value | +---------------------+--------------------------------------+ | attachments | [] | | availability_zone | nova | | bootable | false | | consistencygroup_id | None | | created_at | 2021-04-27T13:52:10.000000 | | description | None | | encrypted | True | | id | 33211b21-8d4f-48e9-b76f-ec73ffd19def | | multiattach | False | | name | enc_drive | | properties | | | replication_status | None | | size | 10 | | snapshot_id | None | | source_volid | None | | status | creating | | type | volumes_hdd_encrypted | | updated_at | None | | user_id | 966ad341f4e14920b5f589f900246ccc | +---------------------+--------------------------------------+ Upon volume creation, this will create a one-off encryption key, which is stored in Barbican and applies to this one volume only. In other words, the key created for this volume will be unable to decrypt any other volumes except the one it was created for. Retrieving a volume\u2019s encryption key Once you have created an encrypted volume, you may retrieve a reference to the Barbican secret that represents its encryption key. You do this with the following command: openstack volume show \\ --os-volume-api-version 3.66 \\ -f value \\ -c encryption_key_id \\ enc_drive Instead of the volume name, you can of course also specify its UUID: openstack volume show \\ --os-volume-api-version 3.66 \\ -f value \\ -c encryption_key_id \\ 33211b21-8d4f-48e9-b76f-ec73ffd19def Deleting an encrypted volume When you decide you no longer need an encrypted volume and want to delete it, you can do so with the openstack volume delete command. As long as you do this with the same user account as the one that created the volume, this will succeed without further intervention. However, if you are trying to delete a volume that was created by a different user, you\u2019ll run into the limitation that the secret associated with the volume is owned by that user. As a result, the deletion of the encrypted volume using your own user credentials will fail. There are two options to work around this limitation: You can switch to the user credentials of the user that created the volume (if you have access to them), and proceed with the deletion. You can ask the user that created the volume to add you to the Access Control List (ACL) for the secret . This will enable you to read the secret, and to delete the volume using your own credentials. Block device encryption caveats Once a volume is configured to use encryption and is also attached to an instance in Cleura, some caveats apply that you might want to keep in mind. Sometimes, automatically or through administrator intervention, we move one of your instances to another physical machine. This process is known as live migration, and it normally does not interrupt the instance\u2019s functionality at all \u2014 typically, neither you nor the application users notice that live migration has even happened. This is a very common occurrence when we do routine upgrades of the Cleura platform, during our pre-announced maintenance windows. The same considerations apply to physical node failure. If the physical machine running your instance fails, we can automatically recover it onto another machine \u2014 an action known as evacuation. Live migration or evacuation including encrypted volumes does, however, require that whoever does the migration also has at least read access to the volume\u2019s encryption secret. This means that you have two options: If you do trust us to include your instances in live migrations and evacuations, even if they attach encrypted volumes, then you can add our administrative account to the Access Control List (ACL) for your secrets . If you don\u2019t want to share your secrets but you still want to use encrypted volumes, you should build your own mechanism or process (preferably automated) so that your instances recover in case they become non-functional.","title":"Encrypted volumes"},{"location":"howto/openstack/cinder/encrypted-volumes/#encrypted-volumes","text":"When using Barbican for block storage encryption, you ensure that data in persistent storage volumes is stored in an encrypted fashion. That encryption is transparent to virtual machines (instances) that you attach the volume to.","title":"Encrypted volumes"},{"location":"howto/openstack/cinder/encrypted-volumes/#creating-an-encrypted-volume","text":"For the creation of an encrypted volume, you need to provide a specific volume type. You can retrieve the list of available volume types with the following command: openstack volume type list +--------------------------------------+-----------------------+-----------+ | ID | Name | Is Public | +--------------------------------------+-----------------------+-----------+ | a479a6b0-b283-41a5-b38b-5b08e7f902ca | volumes_hdd_encrypted | True | | d9dfa98a-238d-4ca0-9abf-701fceb05623 | __DEFAULT__ | True | | 86796611-fb12-4628-b6b1-e09469e301d7 | volumes_hdd | True | +--------------------------------------+-----------------------+-----------+ In Cleura, all volume types that support encryption use the suffix _encrypted . To create a volume with encryption, you need to explicitly specify the --type option to the openstack volume create command. The following example creates a volume using the volumes_hdd_encrypted type, naming it enc_drive and setting its size to 10 GiB: openstack volume create \\ --type volumes_hdd_encrypted \\ --size 10 \\ enc_drive +---------------------+--------------------------------------+ | Field | Value | +---------------------+--------------------------------------+ | attachments | [] | | availability_zone | nova | | bootable | false | | consistencygroup_id | None | | created_at | 2021-04-27T13:52:10.000000 | | description | None | | encrypted | True | | id | 33211b21-8d4f-48e9-b76f-ec73ffd19def | | multiattach | False | | name | enc_drive | | properties | | | replication_status | None | | size | 10 | | snapshot_id | None | | source_volid | None | | status | creating | | type | volumes_hdd_encrypted | | updated_at | None | | user_id | 966ad341f4e14920b5f589f900246ccc | +---------------------+--------------------------------------+ Upon volume creation, this will create a one-off encryption key, which is stored in Barbican and applies to this one volume only. In other words, the key created for this volume will be unable to decrypt any other volumes except the one it was created for.","title":"Creating an encrypted volume"},{"location":"howto/openstack/cinder/encrypted-volumes/#retrieving-a-volumes-encryption-key","text":"Once you have created an encrypted volume, you may retrieve a reference to the Barbican secret that represents its encryption key. You do this with the following command: openstack volume show \\ --os-volume-api-version 3.66 \\ -f value \\ -c encryption_key_id \\ enc_drive Instead of the volume name, you can of course also specify its UUID: openstack volume show \\ --os-volume-api-version 3.66 \\ -f value \\ -c encryption_key_id \\ 33211b21-8d4f-48e9-b76f-ec73ffd19def","title":"Retrieving a volume\u2019s encryption key"},{"location":"howto/openstack/cinder/encrypted-volumes/#deleting-an-encrypted-volume","text":"When you decide you no longer need an encrypted volume and want to delete it, you can do so with the openstack volume delete command. As long as you do this with the same user account as the one that created the volume, this will succeed without further intervention. However, if you are trying to delete a volume that was created by a different user, you\u2019ll run into the limitation that the secret associated with the volume is owned by that user. As a result, the deletion of the encrypted volume using your own user credentials will fail. There are two options to work around this limitation: You can switch to the user credentials of the user that created the volume (if you have access to them), and proceed with the deletion. You can ask the user that created the volume to add you to the Access Control List (ACL) for the secret . This will enable you to read the secret, and to delete the volume using your own credentials.","title":"Deleting an encrypted volume"},{"location":"howto/openstack/cinder/encrypted-volumes/#block-device-encryption-caveats","text":"Once a volume is configured to use encryption and is also attached to an instance in Cleura, some caveats apply that you might want to keep in mind. Sometimes, automatically or through administrator intervention, we move one of your instances to another physical machine. This process is known as live migration, and it normally does not interrupt the instance\u2019s functionality at all \u2014 typically, neither you nor the application users notice that live migration has even happened. This is a very common occurrence when we do routine upgrades of the Cleura platform, during our pre-announced maintenance windows. The same considerations apply to physical node failure. If the physical machine running your instance fails, we can automatically recover it onto another machine \u2014 an action known as evacuation. Live migration or evacuation including encrypted volumes does, however, require that whoever does the migration also has at least read access to the volume\u2019s encryption secret. This means that you have two options: If you do trust us to include your instances in live migrations and evacuations, even if they attach encrypted volumes, then you can add our administrative account to the Access Control List (ACL) for your secrets . If you don\u2019t want to share your secrets but you still want to use encrypted volumes, you should build your own mechanism or process (preferably automated) so that your instances recover in case they become non-functional.","title":"Block device encryption caveats"},{"location":"howto/openstack/octavia/tls-lb/","text":"HTTPS-terminating load balancers In Cleura\u2019s load balancing service, OpenStack Octavia , you can configure load balancers so that they manage HTTPS termination. That is to say that the load balancer encrypts and decrypts HTTPS traffic, and forwards HTTP to and from a backend web server. To do so, the load balancer must have access to encryption credentials (such as certificates and private keys), which it stores in Barbican. PKCS #12 Certificate Bundles The PKCS #12 archive format includes SSL certificates, certificate chains, and private keys all in one bundle. Most certificate providers give you the option of downloading certificate credentials using the PKCS #12 format. In case your certificate provider has made your certificate chain and key available seperately, using the PEM format, you can easily convert it to PKCS #12 using the following openssl command: openssl pkcs12 -export -inkey key.pem -in fullchain.pem -out bundle.p12 When prompted for an export password, use a blank one. Creating Barbican secrets from PKCS #12 bundles To create a secret from a stored PKCS #12 bundle, you need pass in the contents of the bundle, pre-encoded with Base64 , as the secret\u2019s payload. openstack secret store \\ --name='tls_secret1' \\ -t 'application/octet-stream' \\ -e 'base64' \\ --payload=\"$(base64 < server.p12)\" +---------------+---------------------------------------------------------------------------------+ | Field | Value | +---------------+---------------------------------------------------------------------------------+ | Secret href | https://kna1.citycloud.com:9311/v1/secrets/69bd82f5-60c9-4764-99ec-7a3dff05d2aa | | Name | tls_secret1 | | Created | None | | Status | None | | Content types | {'default': 'application/octet-stream'} | | Algorithm | aes | | Bit length | 256 | | Secret type | opaque | | Mode | cbc | | Expiration | None | +---------------+---------------------------------------------------------------------------------+ Creating HTTPS-enabled load balancer listeners Once you have created your secret containing your certificate data, you can create a load balancer listener with the following properties: It uses the TERMINATED_HTTPS protocol, It sets its \u201cdefault TLS container\u201d to the Barbican secret containing the PKCS #12 bundle, It listens on the standard HTTPS port, 443. You create such a listener with the following command: openstack loadbalancer listener create \\ --protocol-port 443 \\ --protocol TERMINATED_HTTPS \\ --name listener1 \\ --default-tls-container=https://kna1.citycloud.com:9311/v1/secrets/dacfbec1-fbed-403f-a4dc-303e28942dae \\ <loadbalancer-name-or-id> +-----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Field | Value | +-----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | admin_state_up | True | | connection_limit | -1 | | created_at | 2021-01-20T11:51:46 | | default_pool_id | None | | default_tls_container_ref | https://kna1.citycloud.com:9311/v1/secrets/dacfbec1-fbed-403f-a4dc-303e28942dae | | description | | | id | 4ec6b23d-d08a-4de0-9e12-54ac690ee1ec | | insert_headers | None | | l7policies | | | loadbalancers | 2c2a0760-c3a8-48d2-bdd0-288c3d33a43f | | name | listener1 | | operating_status | OFFLINE | | project_id | 4a9484063d4c40d29301ad745c0e2c69 | | protocol | TERMINATED_HTTPS | | protocol_port | 443 | | provisioning_status | PENDING_CREATE | | sni_container_refs | [] | | timeout_client_data | 50000 | | timeout_member_connect | 5000 | | timeout_member_data | 50000 | | timeout_tcp_inspect | 0 | | updated_at | None | | client_ca_tls_container_ref | None | | client_authentication | NONE | | client_crl_container_ref | None | | allowed_cidrs | None | | tls_ciphers | TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256 | | tls_versions | | +-----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+","title":"HTTPS-terminating load balancers"},{"location":"howto/openstack/octavia/tls-lb/#https-terminating-load-balancers","text":"In Cleura\u2019s load balancing service, OpenStack Octavia , you can configure load balancers so that they manage HTTPS termination. That is to say that the load balancer encrypts and decrypts HTTPS traffic, and forwards HTTP to and from a backend web server. To do so, the load balancer must have access to encryption credentials (such as certificates and private keys), which it stores in Barbican.","title":"HTTPS-terminating load balancers"},{"location":"howto/openstack/octavia/tls-lb/#pkcs-12-certificate-bundles","text":"The PKCS #12 archive format includes SSL certificates, certificate chains, and private keys all in one bundle. Most certificate providers give you the option of downloading certificate credentials using the PKCS #12 format. In case your certificate provider has made your certificate chain and key available seperately, using the PEM format, you can easily convert it to PKCS #12 using the following openssl command: openssl pkcs12 -export -inkey key.pem -in fullchain.pem -out bundle.p12 When prompted for an export password, use a blank one.","title":"PKCS #12 Certificate Bundles"},{"location":"howto/openstack/octavia/tls-lb/#creating-barbican-secrets-from-pkcs-12-bundles","text":"To create a secret from a stored PKCS #12 bundle, you need pass in the contents of the bundle, pre-encoded with Base64 , as the secret\u2019s payload. openstack secret store \\ --name='tls_secret1' \\ -t 'application/octet-stream' \\ -e 'base64' \\ --payload=\"$(base64 < server.p12)\" +---------------+---------------------------------------------------------------------------------+ | Field | Value | +---------------+---------------------------------------------------------------------------------+ | Secret href | https://kna1.citycloud.com:9311/v1/secrets/69bd82f5-60c9-4764-99ec-7a3dff05d2aa | | Name | tls_secret1 | | Created | None | | Status | None | | Content types | {'default': 'application/octet-stream'} | | Algorithm | aes | | Bit length | 256 | | Secret type | opaque | | Mode | cbc | | Expiration | None | +---------------+---------------------------------------------------------------------------------+","title":"Creating Barbican secrets from PKCS #12 bundles"},{"location":"howto/openstack/octavia/tls-lb/#creating-https-enabled-load-balancer-listeners","text":"Once you have created your secret containing your certificate data, you can create a load balancer listener with the following properties: It uses the TERMINATED_HTTPS protocol, It sets its \u201cdefault TLS container\u201d to the Barbican secret containing the PKCS #12 bundle, It listens on the standard HTTPS port, 443. You create such a listener with the following command: openstack loadbalancer listener create \\ --protocol-port 443 \\ --protocol TERMINATED_HTTPS \\ --name listener1 \\ --default-tls-container=https://kna1.citycloud.com:9311/v1/secrets/dacfbec1-fbed-403f-a4dc-303e28942dae \\ <loadbalancer-name-or-id> +-----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Field | Value | +-----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | admin_state_up | True | | connection_limit | -1 | | created_at | 2021-01-20T11:51:46 | | default_pool_id | None | | default_tls_container_ref | https://kna1.citycloud.com:9311/v1/secrets/dacfbec1-fbed-403f-a4dc-303e28942dae | | description | | | id | 4ec6b23d-d08a-4de0-9e12-54ac690ee1ec | | insert_headers | None | | l7policies | | | loadbalancers | 2c2a0760-c3a8-48d2-bdd0-288c3d33a43f | | name | listener1 | | operating_status | OFFLINE | | project_id | 4a9484063d4c40d29301ad745c0e2c69 | | protocol | TERMINATED_HTTPS | | protocol_port | 443 | | provisioning_status | PENDING_CREATE | | sni_container_refs | [] | | timeout_client_data | 50000 | | timeout_member_connect | 5000 | | timeout_member_data | 50000 | | timeout_tcp_inspect | 0 | | updated_at | None | | client_ca_tls_container_ref | None | | client_authentication | NONE | | client_crl_container_ref | None | | allowed_cidrs | None | | tls_ciphers | TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256 | | tls_versions | | +-----------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+","title":"Creating HTTPS-enabled load balancer listeners"},{"location":"reference/","text":"Reference This is our reference section. If you are an application developer programming against one of our APIs, or you would like to know what a specific term on your invoice refers to, you've come to the right place. The Cleura REST API reference covers our service at https://rest.citycloud.com that you can use to programmatically query your account usage, invoice data, utilization, and many other details available to our Cleura customers. Our Glossary has a list of technical terms you might find on your invoice, in a proposal, or in communications with our sales, support, or professional services staff.","title":"Reference"},{"location":"reference/#reference","text":"This is our reference section. If you are an application developer programming against one of our APIs, or you would like to know what a specific term on your invoice refers to, you've come to the right place. The Cleura REST API reference covers our service at https://rest.citycloud.com that you can use to programmatically query your account usage, invoice data, utilization, and many other details available to our Cleura customers. Our Glossary has a list of technical terms you might find on your invoice, in a proposal, or in communications with our sales, support, or professional services staff.","title":"Reference"},{"location":"tutorials/","text":"About our tutorials Our tutorials are gentle introductions to Cleura. They generally require very little prior knowledge and assume only that you have access to a browser, or to a terminal. We group these into two major categories: Browser-based tutorials get you started on Cleura using the Cleura Cloud Management Console . Terminal-based tutorials introduce you to command-line interfaces (CLIs) and their interaction with Cleura\u2019s web-based Application Programming Interfaces (APIs). This section does not include detailed walkthroughs of specific technical tasks. For those, please see our How-To Guides section. If you find our tutorials helpful, you might also be interested in our self-paced online training courses, available from our course booking site .","title":"About our tutorials"},{"location":"tutorials/#about-our-tutorials","text":"Our tutorials are gentle introductions to Cleura. They generally require very little prior knowledge and assume only that you have access to a browser, or to a terminal. We group these into two major categories: Browser-based tutorials get you started on Cleura using the Cleura Cloud Management Console . Terminal-based tutorials introduce you to command-line interfaces (CLIs) and their interaction with Cleura\u2019s web-based Application Programming Interfaces (APIs). This section does not include detailed walkthroughs of specific technical tasks. For those, please see our How-To Guides section. If you find our tutorials helpful, you might also be interested in our self-paced online training courses, available from our course booking site .","title":"About our tutorials"}]}